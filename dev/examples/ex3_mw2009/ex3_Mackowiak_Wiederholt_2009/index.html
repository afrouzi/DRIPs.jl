<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Replication of Mackowiak and Wiederholt (2009) · DRIPs.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DRIPs.jl</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../overview/">Overview</a></li><li><a class="tocitem" href="../../../syntax/">Syntax</a></li><li><span class="tocitem">Examples and Replications</span><ul><li><a class="tocitem" href="../../ex1_pricing_nofeedback/ex1_pricing_pe_nofeedback/">Pricing under RI w/o Endogenous Feedback</a></li><li><a class="tocitem" href="../../ex2_pricing_wfeedback/ex2_pricing_pe_with_feedback/">Pricing under RI with Endogenous Feedback</a></li><li class="is-active"><a class="tocitem" href>Replication of Mackowiak and Wiederholt (2009)</a><ul class="internal"><li><a class="tocitem" href="#Contents-1"><span>Contents</span></a></li><li><a class="tocitem" href="#mw2009_setup-1"><span>Setup</span></a></li><li><a class="tocitem" href="#mw2009_map_drip-1"><span>Mapping the Problem to a DRIP</span></a></li><li><a class="tocitem" href="#mw2009_param-1"><span>Initialization</span></a></li><li><a class="tocitem" href="#mw2009_funcs-1"><span>Functions</span></a></li><li><a class="tocitem" href="#mw2009_figures-1"><span>Figures</span></a></li><li><a class="tocitem" href="#mw2009_performance-1"><span>Measure Performance/Speed</span></a></li></ul></li><li><a class="tocitem" href="../../ex4_sims2010/ex4_Sims_2010/">Replication of Sims (2010)</a></li><li><a class="tocitem" href="../../ex5_mmw2018/ex5_Mackowiak_Matejka_Wiederholt_2018/">Replication of Mackowiak, Matejka and Wiederholt (2018)</a></li><li><a class="tocitem" href="../../ex6_ay2020/ex6_Afrouzi_Yang_2020/">Replication of the Quantitative Analysis in Afrouzi and Yang (2020)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples and Replications</a></li><li class="is-active"><a href>Replication of Mackowiak and Wiederholt (2009)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Replication of Mackowiak and Wiederholt (2009)</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Replication-of-Mackowiak-and-Wiederholt-(2009)-1"><a class="docs-heading-anchor" href="#Replication-of-Mackowiak-and-Wiederholt-(2009)-1">Replication of Mackowiak and Wiederholt (2009)</a><a class="docs-heading-anchor-permalink" href="#Replication-of-Mackowiak-and-Wiederholt-(2009)-1" title="Permalink"></a></h1><p>This example replicates <a href="https://www.aeaweb.org/articles?id=10.1257/aer.99.3.769">Mackowiak and Wiederholt (2009)</a> (henceforth MW) using the <a href="https://github.com/afrouzi/DRIPs.jl">DRIPs</a> package.</p><p><a href="https://mybinder.org/v2/gh/afrouzi/DRIPs.jl/binder?filepath=examples"><img src="https://mybinder.org/badge_logo.svg" alt="Binder"/></a> to run and modify the following code (no software is needed on the local machine).</p><p>See <a href="http://www.afrouzi.com/dynamic_inattention.pdf">Afrouzi and Yang (2020)</a> for background on the theory.</p><h2 id="Contents-1"><a class="docs-heading-anchor" href="#Contents-1">Contents</a><a class="docs-heading-anchor-permalink" href="#Contents-1" title="Permalink"></a></h2><ul><li><a href="#mw2009_setup-1">Setup</a></li><li><a href="#mw2009_map_drip-1">Mapping the Problem to a DRIP</a></li><li><a href="#mw2009_param-1">Initialization</a></li><li><a href="#mw2009_funcs-1">Functions</a><ul><li><a href="#mw2009_fpointomega-1">Solving for the fixed point given <span>$\omega$</span></a></li><li><a href="#mw2009_solveomega-1">Solving for the optimal <span>$\omega$</span></a></li></ul></li><li><a href="#mw2009_figures-1">Figures</a><ul><li><a href="#mw2009_fig_benchmark-1">Benchmark Economy</a></li><li><a href="#mw2009_robust_alpha-1">Other values of real rigidity</a></li><li><a href="#mw2009_robust_kappa-1">Other values of information capacity</a></li></ul></li><li><a href="#mw2009_performance-1">Measuring Performance/Speed</a></li></ul><h2 id="mw2009_setup-1"><a class="docs-heading-anchor" href="#mw2009_setup-1">Setup</a><a class="docs-heading-anchor-permalink" href="#mw2009_setup-1" title="Permalink"></a></h2><p>The problem in MW is</p><div>\[\begin{aligned}
    &amp;\min_{\{\hat{\Delta}_{i,t},\hat{z}_{i,t}\}} \left\{ E\left[(\Delta_t-\hat{\Delta}_{i,t})^2\right]+\underset{\equiv \xi}{\underbrace{\left(\frac{\hat{\pi}_{14}}{\hat{\pi}_{11}}\right)}}^2E\left[(z_{i,t}-\hat{z}_{i,t})^2\right]\right\}, \\
    s.t.\quad &amp; \mathcal{I}(\{\Delta_t\};\{\hat{\Delta}_{i,t}\})+\mathcal{I}(\{z_{i,t}\};\{\hat{z}_{i,t}\})\leq \kappa, \\
    &amp; \{\Delta_t,\hat{\Delta}_{i,t}\} \perp \{z_{i,t},\hat{z}_{i,t}\}
\end{aligned}\]</div><p>where</p><div>\[\begin{aligned}
    \Delta_t&amp;\equiv p_t + \underset{\equiv 1-\alpha}{\underbrace{\left(\frac{|\hat{\pi}_{13}|}{|\hat{\pi}_{11}|}\right)}}(q_t-p_t) \\
    p_t &amp;= \int_0^1 \hat{\Delta}_{i,t}di \\
    q_t &amp;= \rho q_{t-1} + \nu_t, \nu_{q,t}\sim \mathcal{N}(0,\sigma_q^2) \\
    z_{i,t}&amp;= \rho z_{i,t-1} + \nu_{z,t}, \nu_{z,t}\sim \mathcal{N}(0,\sigma_z^2)
\end{aligned}\]</div><h2 id="mw2009_map_drip-1"><a class="docs-heading-anchor" href="#mw2009_map_drip-1">Mapping the Problem to a DRIP</a><a class="docs-heading-anchor-permalink" href="#mw2009_map_drip-1" title="Permalink"></a></h2><p>There are a few ways of translating the problem above to a <code>Drip</code> structure; however, the most efficient way, due to the independence assumption, is to write it as the sum of two DRIPs: one that solves the attention problem for the idiosyncratic shock, and one that solves the attention problem for the aggregate shock which also has endogenous feedback.</p><p>Moreover, since the problem above has a fixed capacity, instead of a fixed cost of attention (<span>$\omega$</span>) as in DRIPs pacakge, we need to iterate over <span>$\omega$</span>&#39;s to find the one that corresponds with <span>$\kappa$</span>.</p><h2 id="mw2009_param-1"><a class="docs-heading-anchor" href="#mw2009_param-1">Initialization</a><a class="docs-heading-anchor-permalink" href="#mw2009_param-1" title="Permalink"></a></h2><p>Include the package::</p><pre><code class="language-julia">using DRIPs;
nothing #hide</code></pre><p>Assign parameters:</p><pre><code class="language-julia">ρ  = 0.95;
σq = 0.01;
σz = 11.8*σq;
κ  = 3;
ξ  = 1;
α  = 1 - 0.15;
nothing #hide</code></pre><p>Primitives of Drip:</p><pre><code class="language-julia">using LinearAlgebra;
L  = 21; # length of trunction
A  = [zeros(1,L);[Matrix(I,L-1,L-1);zeros(1,L-1)]&#39;]; # MW truncate the state space with linear irfs of length 20
Qq = zeros(L,1); Qq[1]=σq;
Qz = zeros(L,1); Qz[1]=σz;
H  = zeros(L,1); H[1:21] = Array(1:-1/20:0);
nothing #hide</code></pre><h2 id="mw2009_funcs-1"><a class="docs-heading-anchor" href="#mw2009_funcs-1">Functions</a><a class="docs-heading-anchor-permalink" href="#mw2009_funcs-1" title="Permalink"></a></h2><p>We start with a function that solves the aggregate problem with feedback for a given <span>$\omega$</span>.</p><h3 id="mw2009_fpointomega-1"><a class="docs-heading-anchor" href="#mw2009_fpointomega-1">Solving for the fixed point given <span>$\omega$</span></a><a class="docs-heading-anchor-permalink" href="#mw2009_fpointomega-1" title="Permalink"></a></h3><pre><code class="language-julia">function agg_drip(ω,A,Qq,        #primitives of drip except for H because H is endogenous
                  α,             #strategic complementarity
                  H;             #state space rep. of q
                  β     = 1,     #optional: discount factor, MW&#39;s parameterization implies β = 1
                  H0    = H,     #optional: initial guess for HΔ (H is the true solution when α=0)
                  maxit = 10000, #optional: max number of iterations for GE code
                  tol   = 1e-4,  #optional: tolerance for iterations
                  w     = 1)     #optional: update weight for RI
    errmin= 1;
    err   = 1;
    iter  = 0;
    L     = length(H);
    while (err &gt; tol) &amp; (iter &lt; maxit)
            if iter == 0
                global agg  = Drip(ω,β,A,Qq,H0;w = w);
            else
                global agg  = Drip(ω,β,A,Qq,H0;Ω0 = agg.ss.Ω , Σ0 = agg.ss.Σ_1,w = w);
            end

            XFUN(jj) = ((I-agg.ss.K*agg.ss.Y&#39;)*agg.A)^jj * (agg.ss.K*agg.ss.Y&#39;) * (agg.A&#39;)^jj
            X = DRIPs.infinitesum(XFUN; maxit=200, start = 0);  #E[x⃗]=X×x⃗

            XpFUN(jj) = α^jj * X^(jj)
            Xp = DRIPs.infinitesum(XpFUN; maxit=200, start = 0);

            H1 = (1-α)*Xp&#39;*H;

            err= 0.5*norm(H1-H0,2)/norm(H0)+0.5*err;
            if DRIPs.capacity(agg) &lt; 1e-2 # perturb the initial guess if solution is the zero capacity one
                H0 = H0+rand(L).*(H-H0);
            else # store the solution if it has positive capacity
                H0 = H1;
                if err &lt; errmin
                    global aggmin = agg;
                    errmin = err;
                end
            end
            iter += 1;
    end
    return(aggmin, errmin)
end;
nothing #hide</code></pre><p>Now we need a function that iterates over <span>$\omega$</span>&#39;s to find the one that corresponds to a given capacity for the MW problem.</p><h3 id="mw2009_solveomega-1"><a class="docs-heading-anchor" href="#mw2009_solveomega-1">Solving for the optimal <span>$\omega$</span></a><a class="docs-heading-anchor-permalink" href="#mw2009_solveomega-1" title="Permalink"></a></h3><pre><code class="language-julia">using Printf;
function MW(κ,α,A,Qq,Qz,Hq,Hz; #primitives of MW problem
            ω     = σq^2,      #optional: initial guess for ω
            tol   = 1e-3,      #optional: tolerance for κ
            maxit = 10000)     #optional: max iterations
    ωs    = [ω; 2*ω];
    caps  = [];
    iter  = 0;
    err   = 1;
    it    = 0;
    while (err &gt; tol) &amp; (iter &lt; maxit)
        agg, errtemp = agg_drip(ω,A,Qq,α,H; H0 = rand(L),maxit=20,w=0.95);
        idi = Drip(ω,1,A,Qz,H,w = 0.9) ;
        cap = DRIPs.capacity(agg, unit = &quot;bit&quot;) + DRIPs.capacity(idi, unit = &quot;bit&quot;);
        x = ω/σq^2;
        @printf(&quot;ω = %.2fσq² for κ = %.2f \n&quot;,x,cap)
        push!(caps,cap);
        if it == 0
            ω = ωs[end];
        else
            slope = (caps[end]-caps[end-1])/(ωs[end]-ωs[end-1]);
            ω     = ω + (κ-caps[end])/slope;
            push!(ωs,ω);
        end
        err = abs(caps[end] - κ)/κ;
        it  += 1;
    end
    return(ω);
end;
nothing #hide</code></pre><h2 id="mw2009_figures-1"><a class="docs-heading-anchor" href="#mw2009_figures-1">Figures</a><a class="docs-heading-anchor-permalink" href="#mw2009_figures-1" title="Permalink"></a></h2><p>Start with the benchmark calibration:</p><h3 id="mw2009_fig_benchmark-1"><a class="docs-heading-anchor" href="#mw2009_fig_benchmark-1">Benchmark Economy</a><a class="docs-heading-anchor-permalink" href="#mw2009_fig_benchmark-1" title="Permalink"></a></h3><pre><code class="language-julia">ω = MW(3,α,A,Qq,Qz,H,H);

agg, err  = agg_drip(ω,A,Qq,α,H; H0 = rand(L), maxit = 500, w = 0.95);
idi       = Drip(ω,1,A,Qz,H,w = 0.9);

@printf(&quot;Agg. Capacity = %.2f bits, Idio. Capacity = %.2f bits&quot;,DRIPs.capacity(agg),DRIPs.capacity(idi));
nothing #hide</code></pre><pre><code class="language-none">ω = 1.00σq² for κ = 3.67 
ω = 2.00σq² for κ = 3.10 
ω = 2.17σq² for κ = 3.03 
ω = 2.27σq² for κ = 2.98 
ω = 2.23σq² for κ = 3.00 
Agg. Capacity = 0.12 bits, Idio. Capacity = 2.90 bits</code></pre><p>Plot IRFs</p><pre><code class="language-julia">iirfs  = irfs(idi, T = L)
airfs  = irfs(agg, T = L)

using Plots, LaTeXStrings; pyplot();
p1 = plot([iirfs.a[1,1,:],σz*H],
     label             = [&quot;Perfect information&quot; &quot;Rational inattention&quot;],
     marker            = [:square :circle],
     color             = [:gray25 :black],
     markercolor       = [false :black],
     markerstrokecolor = [:gray25 :black],
     markersize        = [7 3],
     xlabel            = &quot;Periods&quot;,
     ylabel            = &quot;Impulse responses to shocks \n of one standard deviation&quot;);
p2 = plot([σq*H,airfs.a[1,1,1:end],σq*agg.H],
     label             = [&quot;Perfect information&quot; &quot;Rational inattention&quot; L&quot;$\Delta$ at the fixed point w/ RI&quot;],
     marker            = [:circle :square :utriangle],
     color             = [:black :gray25 :gray50],
     markercolor       = [:black false false] ,
     markerstrokecolor = [:black :gray25 :gray50],
     markersize        = [3 7 7],
     xlabel            = &quot;Periods&quot;,
     ylabel            = &quot;Impulse responses to shocks \n of one standard deviation&quot;)

plot(p1,p2,
    layout     = (2,1),
    xlim       = (0,L+1),
    lw         = 1,
    legend     = :topright,
    legendfont = font(12),
    tickfont   = font(12),
    size       = (1000,550),
    xticks     = 1:2:21,
    framestyle = :box)</code></pre><p><img src="../2105903046.png" alt/></p><h3 id="mw2009_robust_alpha-1"><a class="docs-heading-anchor" href="#mw2009_robust_alpha-1">Other values of real rigidity (<span>$\alpha$</span>)</a><a class="docs-heading-anchor-permalink" href="#mw2009_robust_alpha-1" title="Permalink"></a></h3><p>For <span>$\alpha = 0.7$</span>:</p><pre><code class="language-julia">ω_α7 = MW(3,0.7,A,Qq,Qz,H,H);

agg_α7, err = agg_drip(ω_α7,A,Qq,0.7,H; H0 = rand(L), maxit = 100, w = 0.95);
idi_α7      = Drip(ω_α7,1,A,Qz,H,w = 0.9);

@printf(&quot;Agg. Capacity = %.2f bits, Idio. Capacity = %.2f bits&quot;,
        DRIPs.capacity(agg_α7),DRIPs.capacity(idi_α7));
nothing #hide</code></pre><pre><code class="language-none">ω = 1.00σq² for κ = 3.83 
ω = 2.00σq² for κ = 3.19 
ω = 2.30σq² for κ = 3.06 
ω = 2.46σq² for κ = 3.01 
ω = 2.47σq² for κ = 3.00 
Agg. Capacity = 0.17 bits, Idio. Capacity = 2.83 bits</code></pre><p>For <span>$\alpha = 0$</span>:</p><pre><code class="language-julia">ω_α0 = MW(3,0,A,Qq,Qz,H,H);

agg_α0, err = agg_drip(ω_α0,A,Qq,0,H; H0 = rand(L), maxit = 100, w = 0.95);
idi_α0      = Drip(ω_α0,1,A,Qz,H,w = 0.9);

@printf(&quot;Agg. Capacity = %.2f bits, Idio. Capacity = %.2f bits&quot;,
        DRIPs.capacity(agg_α0),DRIPs.capacity(idi_α0));
nothing #hide</code></pre><pre><code class="language-none">ω = 1.00σq² for κ = 4.06 
ω = 2.00σq² for κ = 3.39 
ω = 2.59σq² for κ = 3.16 
ω = 2.99σq² for κ = 3.03 
ω = 3.08σq² for κ = 3.00 
Agg. Capacity = 0.32 bits, Idio. Capacity = 2.68 bits</code></pre><p>Plot IRFs:</p><pre><code class="language-julia">airfs_α7  = irfs(agg_α7, T = L);
airfs_α0  = irfs(agg_α0, T = L);

plot(1:L,0.75*[σq*H,airfs.a[1,1,:],airfs_α7.a[1,1,:],airfs_α0.a[1,1,:]],
    label             = [&quot;Perfect information&quot; L&quot;Rational inattention, benchmark economy, $\alpha = 0.85$&quot; L&quot;Lower degree of real rigidity, $\alpha = 0.7$&quot; L&quot;Lower degree of real rigidity, $\alpha = 0$&quot;],
    marker            = [:circle :square :x :circle],
    color             = [:black :gray20 :gray40 :gray60],
    markercolor       = [:black false :gray40 false],
    markerstrokecolor = [:black :gray20 :gray40 :gray60],
    markersize        = [3 7 7 7],
    xlim              = (0,L+1),
    lw                = 1,
    xticks            = 1:2:21,
    legend            = :topright,
    legendfont        = font(11),
    tickfont          = font(11),
    size              = (1000,275),
    ylim              = (0,σq),
    framestyle        = :box,
    xlabel            = &quot;Periods&quot;,
    ylabel            = &quot;Impulse responses to shocks \n of one standard deviation&quot;)</code></pre><p><img src="../2122655196.png" alt/></p><h3 id="mw2009_robust_kappa-1"><a class="docs-heading-anchor" href="#mw2009_robust_kappa-1">Other values of information capacity (<span>$\kappa$</span>)</a><a class="docs-heading-anchor-permalink" href="#mw2009_robust_kappa-1" title="Permalink"></a></h3><p>For <span>$\kappa=4$</span>:</p><pre><code class="language-julia">ω_κ4 = MW(4,α,A,Qq,Qz,H,H);

agg_κ4, err = agg_drip(ω_κ4,A,Qq,α,H; H0 = rand(L), maxit = 500, w = 0.95)
idi_κ4      = Drip(ω_κ4,1,A,Qz,H,w = 0.9)

@printf(&quot;Agg. Capacity = %.2f bits, Idio. Capacity = %.2f bits&quot;,
        DRIPs.capacity(agg_κ4),DRIPs.capacity(idi_κ4));
nothing #hide</code></pre><pre><code class="language-none">ω = 1.00σq² for κ = 3.66 
ω = 2.00σq² for κ = 3.09 
ω = 0.41σq² for κ = 4.52 
ω = 0.99σq² for κ = 3.68 
ω = 0.77σq² for κ = 3.92 
ω = 0.70σq² for κ = 4.01 
ω = 0.71σq² for κ = 4.00 
Agg. Capacity = 0.34 bits, Idio. Capacity = 3.66 bits</code></pre><p>For <span>$\kappa=5$</span>:</p><pre><code class="language-julia">ω_κ5 = MW(5,α,A,Qq,Qz,H,H; ω = 0.1*σq^2);

agg_κ5, err = agg_drip(ω_κ5,A,Qq,α,H; H0 = rand(L), maxit = 500, w = 0.95)
idi_κ5      = Drip(ω_κ5,1,A,Qz,H,w = 0.9)

@printf(&quot;Agg. Capacity = %.2f bits, Idio. Capacity = %.2f bits&quot;,
        DRIPs.capacity(agg_κ5),DRIPs.capacity(idi_κ5));
nothing #hide</code></pre><pre><code class="language-none">ω = 0.10σq² for κ = 6.14 
ω = 0.20σq² for κ = 5.29 
ω = 0.23σq² for κ = 5.12 
ω = 0.26σq² for κ = 5.01 
ω = 0.26σq² for κ = 5.00 
Agg. Capacity = 0.70 bits, Idio. Capacity = 4.30 bits</code></pre><p>Plot IRFs:</p><pre><code class="language-julia">airfs_κ4  = irfs(agg_κ4, T = L);
airfs_κ5  = irfs(agg_κ5, T = L);

plot(1:L,0.75*[σq*H,airfs.a[1,1,:],airfs_κ4.a[1,1,:],airfs_κ5.a[1,1,:]],
    label             = [&quot;Perfect information&quot; L&quot;Rational inattention, benchmark economy, $\kappa = 3$&quot; L&quot;Rational inattention $\kappa = 4$&quot; L&quot;Rational inattention $\kappa = 5$&quot;],
    marker            = [:circle :square :x :circle],
    color             = [:black :gray20 :gray40 :gray60],
    markercolor       = [:black false :gray40 false],
    markerstrokecolor = [:black :gray20 :gray40 :gray60],
    markersize        = [3 7 7 7],
    xlim              = (0,L+1),
    lw                = 1,
    xticks            = 1:2:21,
    legend            = :topright,
    legendfont        = font(11),
    tickfont          = font(11),
    size              = (1000,275),
    ylim              = (0,σq),
    framestyle        = :box,
    xlabel            = &quot;Periods&quot;,
    ylabel            = &quot;Impulse responses to shocks \n of one standard deviation&quot;)</code></pre><p><img src="../2582291013.png" alt/></p><h2 id="mw2009_performance-1"><a class="docs-heading-anchor" href="#mw2009_performance-1">Measure Performance/Speed</a><a class="docs-heading-anchor-permalink" href="#mw2009_performance-1" title="Permalink"></a></h2><h3 id="Performance-of-the-code-for-aggregate-problem-with-feedback-1"><a class="docs-heading-anchor" href="#Performance-of-the-code-for-aggregate-problem-with-feedback-1">Performance of the code for aggregate problem with feedback</a><a class="docs-heading-anchor-permalink" href="#Performance-of-the-code-for-aggregate-problem-with-feedback-1" title="Permalink"></a></h3><p>For random values of <span>$\omega$</span> and benchmark values of other parameters:</p><pre><code class="language-julia">using BenchmarkTools;
@benchmark agg_drip(ω,A,Qq,α,H; H0 = rand(L), maxit = 100, w = 0.95) setup = (ω = σq^2*5*rand())</code></pre><pre><code class="language-none">BenchmarkTools.Trial: 
  memory estimate:  431.88 MiB
  allocs estimate:  197363
  --------------
  minimum time:     532.473 ms (6.11% GC)
  median time:      561.720 ms (6.51% GC)
  mean time:        561.793 ms (6.35% GC)
  maximum time:     596.280 ms (6.15% GC)
  --------------
  samples:          9
  evals/sample:     1</code></pre><p>For <span>$\alpha=0.7$</span> and random values of <span>$\omega$</span>:</p><pre><code class="language-julia">@benchmark agg_drip(ω_α7,A,Qq,0.7,H; H0 = rand(L), maxit = 100, w = 0.95) setup = (ω = σq^2*5*rand())</code></pre><pre><code class="language-none">BenchmarkTools.Trial: 
  memory estimate:  59.14 MiB
  allocs estimate:  25584
  --------------
  minimum time:     61.127 ms (6.65% GC)
  median time:      88.009 ms (9.27% GC)
  mean time:        84.948 ms (7.36% GC)
  maximum time:     108.039 ms (7.57% GC)
  --------------
  samples:          59
  evals/sample:     1</code></pre><h3 id="Performance-of-the-code-for-idiosyncratic-problem-1"><a class="docs-heading-anchor" href="#Performance-of-the-code-for-idiosyncratic-problem-1">Performance of the code for idiosyncratic problem</a><a class="docs-heading-anchor-permalink" href="#Performance-of-the-code-for-idiosyncratic-problem-1" title="Permalink"></a></h3><pre><code class="language-julia">@benchmark Drip(ω,1,A,Qz,H,w = 0.9) setup = (ω = σq^2*5*rand())</code></pre><pre><code class="language-none">BenchmarkTools.Trial: 
  memory estimate:  12.68 MiB
  allocs estimate:  6192
  --------------
  minimum time:     17.451 ms (0.00% GC)
  median time:      18.556 ms (0.00% GC)
  mean time:        19.451 ms (4.91% GC)
  maximum time:     23.638 ms (17.43% GC)
  --------------
  samples:          257
  evals/sample:     1</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../ex2_pricing_wfeedback/ex2_pricing_pe_with_feedback/">« Pricing under RI with Endogenous Feedback</a><a class="docs-footer-nextpage" href="../../ex4_sims2010/ex4_Sims_2010/">Replication of Sims (2010) »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 27 September 2020 05:27">Sunday 27 September 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
