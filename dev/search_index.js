var documenterSearchIndex = {"docs":
[{"location":"overview/#The-Problem-1","page":"Overview","title":"The Problem","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"A LQG Dynamic Rational Inattention Problem (Drip) is defined as the following tracking problem, where at any point in time the agent chooses a vector of actions veca_tinmathbbR^m to track a Gaussian stochastic process vecx_tinmathbbR^n:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"beginaligned\n     min_veca_t_tgeq 0 mathbbEleftsum_t=0^infty beta^t (veca_t - vecx_tmathbfH)(veca_t - vecx_tmathbfH) - omega mathbbI(veca^tvecx^tveca^t-1)lvert veca^-1right \n    stquad \n        vecx_t=mathbfAvecx_t-1+mathbfQvecu_tquad vecu_tsim mathcalN(mathbf0mathbfI^ktimes k) \n        veca^-1 text given\nendaligned","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Here:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"veca_tinmathbbR^m is the vector of the agent's actions at time t (a firms choosing a price, or a househld choosing consumption and labor etc.) We denote the number of actions by m.\nvecx_tinmathbbR^n is the vector of the shocks that the agent faces at time t that are exogenous to her decision, but could be endogenous to the GE model (marginal cost of a firm, real interest rates etc.) We denote the number of shocks by n.","category":"page"},{"location":"overview/#The-Parameters-1","page":"Overview","title":"The Parameters","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"The LQG-DRI problem is characterized by the following parameters:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"omegain mathbbR_+: cost of 1 bit of information in units of the agent's payoff.\nbetain01: rate of discounting information.\nmathbfAin mathbbR^ntimes n mathbfQinmathbbR^ntimes k: Determine the state space representation of vecx_t.\nmathbfHin mathbbR^ntimes m: interaction of payoffs with shocks. This comes from a second order approximation to the utility function and is such that under full information veca^*=mathbfHvecx.","category":"page"},{"location":"overview/#The-Solution-1","page":"Overview","title":"The Solution","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"The solution to the dynamic rational inattention problem is a joint stochastic process between the actions and the states: (veca_tvecx_t)tgeq 0. Moreover, in some economic applications, we are also interested in the law of motion for the agent's belief about vecx_t under the optimal information structure hatx_t=mathbbE_tvecx_t where the expectation is taken conditional on the agent's time t information.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Theorem 2 and Proposition 3 in Afrouzi and Yang (2019) characterize this joint distribution as a function of a tuple (mathbfK_tmathbfY_tmathbfSigma_zt) where","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"beginaligned\n    veca_t = mathbfHhatx_t = mathbfHmathbfAhatx_t-1+mathbfY_t(vecx_t-mathbfAhatx_t-1)+vecz_t \n    hatx_t = mathbfAhatx_t-1+mathbfK_tmathbfY_t(vecx_t-mathbfAhatx_t-1)+mathbfK_tvecz_tquad veczsimmathcalN(0Sigma_z)\nendaligned","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Here,","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"mathbfK_tinmathbbR^ntimes m is the Kalman-gain matrix of the agent in under optimal information acquisition at time t.\nmathbfY_tinmathbbR^mtimes m is the loading of optimal signals on the state at time t.\nmathbfSigma_ztinmathbbR^mtimes m is the variance-covariance matrix of the agent's rational inattention error at time t.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"In addition to these, we might also be interested in the agent's prior and posterior subjective uncertainty, along with the continuation value that she assigns to information:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"mathbfSigma_pt=mathbbVar(vecx_tveca^t)inmathbbR^ntimes n.\nmathbfSigma_-1t=mathbbVar(vecx_tveca^t-1)inmathbbR^ntimes n,\nbarOmegainmathbbR^ntimes n.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"The matrix barOmega, which is the continuation value of information, is also important for the number of iterations that the code needs to converge. When n is large, accurate guesses for barOmega and mathbfSigma_-1 speed up the convergence considerably.","category":"page"},{"location":"overview/#Steady-State-of-DRIPs-1","page":"Overview","title":"Steady State of DRIPs","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"The solver function is solve_drip(ω,β,A,Q,H). It takes the primitives (ω,β,A,Q,H) as arguments and returns the solution of the model within a Drip structure that contains all the primitives and the solution objects of the model.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"See the syntax section for Drip methods for the definition of the Drip structure as well as for more information about solve_drip.","category":"page"},{"location":"overview/#Transition-Dynamics-of-DRIPs-1","page":"Overview","title":"Transition Dynamics of DRIPs","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"The Euler equation derived in Afrouzi and Yang (2019) for the  also allows us to characterize the transition path of the information structure over time for an arbitrary initial prior.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"The function solve_trip(P::Drip,s0) takes the steady state solution P=solve_drip(.) along with an initial condition s0 as an input and returns a Trip structure that summarizes the transition path of the optimal information structure. The initial condition s0 can be given either as an initial prior covariance matrix or alternatively as a one time signal about the state that perturbs the steady state prior.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"See the syntax section for Trip methods for the definition of the Trip structure as well as for more information about solve_trip.","category":"page"},{"location":"overview/#Impulse-Response-Functions-1","page":"Overview","title":"Impulse Response Functions","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Once the model is solved, one can generate the impulse response functions of actions and beliefs using the laws of motion stated above.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"We have also included a built-in function that generates these IRFs. The function dripirfs(P::Drip) takes a Drip structure as input and returns the irfs of the state, beliefs and actions to all structural shocks within a Dripirfs structure.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"The function also returns IRFs for transition dynamics if an initial signal is specified. See the syntax section for Trip methods for the definition of the Dripirfs structure as well as for more information about dripirfs.","category":"page"},{"location":"#Dynamic-Rational-Inattention-Problems-1","page":"Home","title":"Dynamic Rational Inattention Problems","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package provides a fast and robust method for solving LQG Dynamic Rational Inattention models using the methods developed by Afrouzi and Yang (2019).","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To add the package, execute:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"DRIPs\");","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To import and use the package, execute:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using DRIPs;","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"overview.md\"]\nDepth = 3","category":"page"},{"location":"#Syntax-1","page":"Home","title":"Syntax","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"syntax.md\",]\nDepth = 3","category":"page"},{"location":"syntax/#DRIP_methods-1","page":"Syntax","title":"Methods for Steady State of DRIPs","text":"","category":"section"},{"location":"syntax/#","page":"Syntax","title":"Syntax","text":"Modules = [DRIPs]\nPages   = [\"drip_methods.jl\"]","category":"page"},{"location":"syntax/#DRIPs.Drip","page":"Syntax","title":"DRIPs.Drip","text":"Summary\n\nA [Mutable] Structure for LQG Dynamic Rational Inattention Problems (DRIPs)\n\nFields\n\nPrimitives of the DRIP\n\nω      : Cost of information\nβ      : Discount factor\nA      : Transition matrix: x=Ax+Qu\nQ      : Std. Dev. matrix: x=Ax+Qu\nH      : Mapping of shocks to actions: v=-0.5(a'-x'H)(a-H'x)\n\nSolution of the DRIP in the Steady State\n\nK      : Kalman gain matrix\nY      : Weight vector for evolution of actions\nΣ_z    : Covariance matrix of the rational inattention error\nΣ_p    : Steady-state posterior covariance matrix under the solution\nΣ_1    : Steady-state prior covariance matrix under the solution\nΩ      : Dynamic benefit matrix\nerr    : Convergence error for the solution\n\n\n\n\n\n","category":"type"},{"location":"syntax/#DRIPs.solve_drip-NTuple{5,Any}","page":"Syntax","title":"DRIPs.solve_drip","text":"solve_drip(ω,β,A,Q,H;\n           fcap  = false,\n           Ω0    = H*H',\n           Σ0    = A*A'+Q*Q',\n           w     = 1,\n           tol   = 1e-4,\n           maxit = 10000) -> Drip\n\nSolves for the steady state of a Dynamic Rational Inattention Problem (DRIP)     defined by the arguments. See Afrouzi and  Yang (2019)     for details.\n\nArguments\n\nThe function takes the primitives of the Drip as arguments:\n\n* ω      : Cost of information\n* β      : Discount factor\n* A      : Transition matrix: x=Ax+Qu\n* Q      : Std. Dev. matrix: x=Ax+Qu\n* H      : Mapping of shocks to actions: v=-0.5(a'-x'H)(a-H'x)\n\nOptional Arguments\n\nDefault values are set unless specified otherwise by user.\n\n* fcap  = false    [if `true` then solves the problem with fixed capacity = ω bits]\n* Ω0    = H*H'     [initial guess for steady state information matrix]\n* Σ0    = A*A'+Q*Q'[initial guess for steady state prior]\n* w     = 1        [updating weight on the new guess in iteration]\n* tol   = 1e-4     [tolerance level for convergence]\n* maxit = 10000    [maximum number of iterations]\n\nOutputs\n\nThe function returns a Drip structure with the primitives and the solution objects:\n\n* Y      : Weight vector for evolution of actions\n* Σ_z    : Covariance matrix of the rational inattention error\n* K      : Kalman gain matrix\n* Σ_1    : Steady-state prior covariance matrix under the solution\n* Σ_p    : Steady-state posterior covariance matrix under the solution\n* Ω      : Dynamic benefit matrix\n\nExamples\n\njulia> P = solve_drip(ω,β,A,Q,H)\n\n\n\n\n\n","category":"method"},{"location":"syntax/#DRIPs.solve_drip-Tuple{Drip}","page":"Syntax","title":"DRIPs.solve_drip","text":"solve_drip(P::Drip;...) -> Drip\n\nSame as above but infers ω,β,A,Q and H from P and returns a Drip structure with the primitives and the solution.\n\nExamples\n\njulia> P = Drip(ω,β,A,Q,H)\njulia> P = solve_drip(P)\n\n\n\n\n\n","category":"method"},{"location":"syntax/#TRIP_methods-1","page":"Syntax","title":"Methods for Transition dynamics of DRIPs","text":"","category":"section"},{"location":"syntax/#","page":"Syntax","title":"Syntax","text":"Modules = [DRIPs]\nPages   = [\"trip_methods.jl\"]","category":"page"},{"location":"syntax/#DRIPs.Signal","page":"Syntax","title":"DRIPs.Signal","text":"Summary\n\nA Signal Structure for Information Treatments in DRIPs. The structure encodes   the signal S = L'*x+z, z₀~N(0,Σ_z).\n\nFields\n\nL    : loading of the signal on x\nΣ_z  : variance covariance matrix of the noise\n\n\n\n\n\n","category":"type"},{"location":"syntax/#DRIPs.Trip","page":"Syntax","title":"DRIPs.Trip","text":"Summary\n\nA Structure for the Transition dynamics of Rational Inattention Problems (TRIPs)\n\nFields\n\nP    : a DRIP structure with its primitives and steady state solution\nT    : length of TRIP\nΣ_1s : sequence of prior covariance matrices\nΣ_ps : sequence of posterior covariance matrices\nΩs   : sequence of information benefit matrices\nDs   : eigenvalues of Σ_t^(0.5)Ω_tΣ_t^(0.5) over time (marginal values of information)\nerr  : convergence err\n\n\n\n\n\n","category":"type"},{"location":"syntax/#DRIPs.solve_trip-Tuple{Drip,Array{Float64,N} where N}","page":"Syntax","title":"DRIPs.solve_trip","text":"     solve_trip(Ss::Drip,             # steady state of D.R.I.P.\n                Σ0::Array{Float64,2}; # initial prior matrix\n                T     = 100,          # optional: guess for time until convergence to steady state\n                tol   = 1e-4,         # optional: tolerance for convergence\n                maxit = 1000          # optional: max iterations\n                ) -> Trip\n\nSolves for the transition dynamics of the optimal information structure starting     from the initial prior distribution with covariance matrix Σ0.     See Afrouzi and  Yang (2019)     for details.\n\nOutputs\n\nReturns a Trip structure with the steady state and transition path of     the optimal information structure.\n\nExamples\n\njulia> Ss = solve_drip(ω,β,A,Q,H)\njulia> Σ0 = 0.1*Ss.Σ_1;\njulia> Pt = solve_trip(Ss,Σ0);\n\n\n\n\n\n","category":"method"},{"location":"syntax/#DRIPs.solve_trip-Tuple{Drip,Signal}","page":"Syntax","title":"DRIPs.solve_trip","text":"     solve_trip(Ss::Drip,             # steady state of D.R.I.P.\n                S::Signal;            # information treatment in the steady state\n                T     = 100,          # optional: guess for time until convergence to steady state\n                tol   = 1e-4,         # optional: tolerance for convergence\n                maxit = 1000          # optional: max iterations\n                ) -> Trip\n\nSolves for the transition dynamics of the optimal information structure starting     from a one time treatment with a signal S in the steady state.     See Afrouzi and  Yang (2019)     for details.\n\nOutputs\n\nReturns a Trip structure with the steady state and transition path of     the optimal information structure.\n\nExamples\n\njulia> Ss = solve_drip(ω,β,A,Q,H)\njulia> S  = Signal(L,Σ_z);\njulia> Pt = solve_trip(Ss,S);\n\n\n\n\n\n","category":"method"},{"location":"syntax/#IRFs-1","page":"Syntax","title":"Impulse Response Functions","text":"","category":"section"},{"location":"syntax/#","page":"Syntax","title":"Syntax","text":"Modules = [DRIPs]\nPages   = [\"dripirfs_methods.jl\"]","category":"page"},{"location":"syntax/#DRIPs.Dripirfs","page":"Syntax","title":"DRIPs.Dripirfs","text":"Summary\n\nA Structure for the impulse response functions of DRIPs\n\nFields\n\nT     : length of IRFs\nx     : IRFs of the fundamental shocks\nx_hat : IRFs of beliefs\na     : IRFs of actions\n\nIn particular, if n is the dimension of x, m is the dimension of a and k is the number of structural shocks, then\n\nx has dimension n*k*T where x(i,j,:) is the impulse response function of   the i'th dimension of x to the j'th structural shock.\nx_hat has dimension n*k*T where x_hat(i,j,:) is the impulse response   function of the agent's average belief about the i'th dimension of x to   the j'th structural shock.\na has dimension m*k*T where a(i,j,:) is the impulse response function of   the i'th action to the j'th structural shock.\n\n\n\n\n\n","category":"type"},{"location":"syntax/#DRIPs.dripirfs-Tuple{Drip,Signal}","page":"Syntax","title":"DRIPs.dripirfs","text":"     dripirfs(Ss::Drip,          # Steady state of the DRIP (when treatment happens)\n              S::Signal;         # Signal for treatment at time 0\n              T = 40,            # optional: length of irfs\n              reoptimize = true, # optional: if true gives the irfs with reoptimized signals, if false with steady state signals\n              trip       = false # optional: if false solves for the optimal trip, if = P::trip then takes P as the transition dynamics after treatment\n              ) -> Dripirfs\n\nReturns a Dripirfs structure with the impulse response functions of the fundamental (x), beliefs (x_hat)     and actions (a) to all the structural shocks     under the information structure implied by a one time information treatment     with S in the steady state of the DRIP P. In particular, if n is the     dimension of x, m is the dimension of a and k is the number of     structural shocks, then\n\nx has dimension n*k*T where x(i,j,:) is the impulse response function   of the i'th dimension of x to the j'th structural shock.\nx_hat has dimension n*k*T where x_hat(i,j,:) is the impulse response function   of the agent's average belief about the i'th dimension of x to the j'th   structural shock.\na has dimension m*k*T where a(i,j,:) is the impulse response function   of the i'th action to the j'th structural shock.\n\n\n\n\n\n","category":"method"},{"location":"syntax/#DRIPs.dripirfs-Tuple{Drip}","page":"Syntax","title":"DRIPs.dripirfs","text":"     dripirfs(P::Drip;  # Steady state of the DRIP\n              T = 40    # Optional: length of impulse response functions\n              ) -> Dripirfs\n\nReturns a Dripirfs structure with the impulse response functions of the fundamental (x), beliefs (x_hat)     and actions (a) to all the structural shocks     under the steady state information strucutre. In particular, if n is the     dimension of x, m is the dimension of a and k is the number of     structural shocks, then\n\nx has dimension n*k*T where x(i,j,:) is the impulse response function   of the i'th dimension of x to the j'th structural shock.\nx_hat has dimension n*k*T where x_hat(i,j,:) is the impulse response function   of the agent's average belief about the i'th dimension of x to the j'th   structural shock.\na has dimension m*k*T where a(i,j,:) is the impulse response function   of the i'th action to the j'th structural shock.\n\n\n\n\n\n","category":"method"},{"location":"syntax/#DRIPs.dripirfs-Tuple{Trip}","page":"Syntax","title":"DRIPs.dripirfs","text":"     dripirfs(P::Trip;  # Transition dynamics of the DRIP\n              T = 40    # Optional: length of impulse response functions\n              ) -> Dripirfs\n\nReturns a Dripirfs structure with the impulse response functions of the fundamental (x), beliefs (x_hat)     and actions (a) to all the structural shocks     under the information structure implied by P. In particular, if n is the     dimension of x, m is the dimension of a and k is the number of     structural shocks, then\n\nx has dimension n*k*T where x(i,j,:) is the impulse response function   of the i'th dimension of x to the j'th structural shock.\nx_hat has dimension n*k*T where x_hat(i,j,:) is the impulse response function   of the agent's average belief about the i'th dimension of x to the j'th   structural shock.\na has dimension m*k*T where a(i,j,:) is the impulse response function   of the i'th action to the j'th structural shock.\n\n\n\n\n\n","category":"method"},{"location":"syntax/#Aux.-Functions-1","page":"Syntax","title":"Aux. Functions","text":"","category":"section"},{"location":"syntax/#","page":"Syntax","title":"Syntax","text":"Modules = [DRIPs]\nPages   = [\"aux_funcs.jl\"]","category":"page"},{"location":"syntax/#DRIPs.capacity-Tuple{Drip}","page":"Syntax","title":"DRIPs.capacity","text":"    capacity(P::Drip;      # Drip structure\n             unit = \"bit\"  # optional: unit of capacity (bit or nat).\n             )\n\nReturns the amount of information processes per unit of time in the steady state of the DRIP P.\n\n\n\n\n\n","category":"method"},{"location":"syntax/#DRIPs.getreal-Tuple{Any}","page":"Syntax","title":"DRIPs.getreal","text":"getreal(M)\n\nReturns the real part of M (Same as real.(M)).\n\n\n\n\n\n","category":"method"},{"location":"syntax/#DRIPs.infinitesum-Tuple{Any}","page":"Syntax","title":"DRIPs.infinitesum","text":"infinitesum(func; tol = 1e-6,maxit = 1000,start=0)\n\nReturns the infinite sum Σₓfunc(x) starting from x = start up to tolderance tol or max iteration maxit.\n\n\n\n\n\n","category":"method"}]
}
